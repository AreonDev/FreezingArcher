using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FreezingArcher.Math;

namespace Henge3D
{
	/// <summary>
	/// Provides facilities for constructing a convex hull from a cloud of points, typically from a simple collision mesh or other
	/// such source. A simple gift-wrapping algorithm is employed.
	/// </summary>
	public class ConvexHull3D
	{
		class Face
		{
			public List<Vertex> Vertices;
			public Face()
			{
				Vertices = new List<Vertex>();
			}
		}

		class Vertex
		{
			public Vector3 Point;
			public List<Face> Faces;
			public float SortValue;
			public Vertex(Vector3 point)
			{
				Point = point;
				Faces = new List<Face>();
			}
		}

		private List<Face> _faces;
		private List<Vertex> _vertices;
		private Vector3 _centroid;

		/// <summary>
		/// Construct a convex hull from the list of vertices.
		/// </summary>
		/// <param name="points">A list of all vertices in the shape.</param>
		public ConvexHull3D(Vector3[] points)
		{
			_faces = new List<Face>();
			_vertices = (from p in points select new Vertex(p)).ToList();

			RemoveDuplicates();
			ComputeCentroid();

			if (_vertices.Count < 4)
				throw new ArgumentException("Input must contain at least 4 distinct points.");

			Build();
		}

		/// <summary>
		/// Create a compiled polyhedron from the convex hull. The polyhedron faces will be constructed properly using the data
		/// generated by the hull.
		/// </summary>
		/// <returns>A new compiled polyhedron object containing all the points in the convex hull.</returns>
		public CompiledPolyhedron ToPolyhedron()
		{
			var vertices = (from v in _vertices
							where v.Faces.Count > 0
							select v).Select((v, i) => new { I = i, V = v });
			var faces = (from f in _faces
						 select (from fv in f.Vertices join v in vertices on fv equals v.V select v.I).ToArray());
			return new CompiledPolyhedron(
				(from v in vertices select v.V.Point).ToArray(),
				faces.ToArray());
		}

		private void ComputeCentroid()
		{
			_centroid = Vector3.Zero;
			foreach (var v in _vertices) _centroid += v.Point;
			_centroid /= _vertices.Count;
		}

		private void RemoveDuplicates()
		{
			for (int i = _vertices.Count - 1; i >= 0; --i)
			{
				for (int j = i - 1; j >= 0; --j)
				{
					var diff = _vertices[i].Point - _vertices[j].Point;
					if (diff.Length < Constants.Epsilon)
					{
						_vertices.RemoveAt(i);
						break;
					}
				}
			}
		}

		private void Build()
		{
			Vertex p, q = null;

			// select maximum vertex along X
			p = _vertices[0];
			for (int i = 1; i < _vertices.Count; i++)
			{
				if (_vertices[i].Point.X > p.Point.X)
					p = _vertices[i];
			}

			// find Q with lowest angle from P around Z axis
			float minAngle = float.PositiveInfinity;
			foreach (var v in _vertices)
			{
				Vector3 vp = v.Point - p.Point;
				vp.Z = p.Point.Z;
				if (v == p || vp.Length < Constants.Epsilon) continue;
				vp.Normalize();
				float angle = (float)Math.Asin(-vp.X);
				if (vp.Y < 0f) angle += MathHelper.PiOver2;
				if (angle < minAngle)
				{
					minAngle = angle;
					q = v;
				}
			}
            if (float.IsPositiveInfinity(minAngle))
				throw new ArgumentException("Input point set is degenerate.");

			BuildNextFace(null, p, q);
		}

		private void BuildNextFace(Face prevFace, Vertex p, Vertex q)
		{
			Vertex r = null;
			Vector3 normal = Vector3.Zero;
			float depth;

			// find point R that is not colinear with P and Q
			bool done = false;
			for (int i = 0; i < _vertices.Count; i++)
			{
				r = _vertices[i];
				if (r == p || r == q) continue;
				if (r.Faces.Contains(prevFace)) continue;
				normal = Vector3.Cross(p.Point - q.Point, r.Point - q.Point);
				if (normal.Length >= Constants.Epsilon)
				{
					done = true;
					break;
				}
			}
			if (!done)
				throw new ArgumentException("Input point set is degenerate.");
			normal.Normalize();

			// find extremal plane containing P and Q
			do
			{
				Vertex r1 = r;
				done = true;
				depth = Vector3.Dot(normal, r.Point);
				foreach (var v in _vertices)
				{
					float x = Vector3.Dot(normal, v.Point);
					if (v == p || v == q || v == r) continue;
					if (x > depth)
					{
						r1 = v;
						depth = x;
						done = false;
					}
				}
				if (!done)
				{
					r = r1;
					normal = Vector3.Cross(p.Point - q.Point, r.Point - q.Point);
					normal.Normalize();
				}
			}
			while (!done);

			// add all vertices on extreme plane
			var face = new Face();
			foreach (var v in _vertices)
			{
				if (Math.Abs(Vector3.Dot(normal, v.Point) - depth) < Constants.Epsilon)
				{
					face.Vertices.Add(v);
					v.Faces.Add(face);
				}
			}
			if (face.Vertices.Count == _vertices.Count)
				throw new ArgumentException("Input point set is degenerate.");

			// sort points
			p = face.Vertices[0];
			q = face.Vertices[1];
			r = face.Vertices[2];
			normal = Vector3.Cross(q.Point - p.Point, r.Point - p.Point);
			normal.Normalize();
			var c = Vector3.Zero;
			foreach (var v in face.Vertices) c += v.Point;
			c /= face.Vertices.Count;
			p.SortValue = 0f;
			var cp = p.Point - c;
			cp.Normalize();
			var up = Vector3.Cross(normal, cp);
			up.Normalize();
			for (int i = 1; i < face.Vertices.Count; i++)
			{
				var v = face.Vertices[i];
				var cv = v.Point - c;
				v.SortValue = (float)Math.Atan2(Vector3.Dot(up, cv), Vector3.Dot(cp, cv));
			}
			face.Vertices.Sort((p1, p2) => Math.Sign(p1.SortValue - p2.SortValue));

			// if points are not CCW, reverse them
			p = face.Vertices[0];
			q = face.Vertices[1];
			r = face.Vertices[2];
			if (Vector3.Dot(Vector3.Cross(r.Point - p.Point, q.Point - p.Point), _centroid - p.Point) < 0f)
			{
				face.Vertices.Reverse();
			}
			_faces.Add(face);

			// continue building opposite faces
			for (int i = 0; i < face.Vertices.Count; i++)
			{
				p = face.Vertices[i];
				q = face.Vertices[i == face.Vertices.Count - 1 ? 0 : i + 1];

				done = false;
				foreach (var f in p.Faces)
				{
					if (f != face && q.Faces.Contains(f))
					{
						done = true;
					}
				}
				if (!done) BuildNextFace(face, p, q);
			}
		}
	}
}
